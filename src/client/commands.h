/**
 * \file commands.h
 * \brief Defines macros to aim to handle commands
 */

#ifndef C_CHAT_COMMANDS_H
#define C_CHAT_COMMANDS_H

#include "ui.h"
#include <string.h>

/**
 * \def COMMAND_HANDLER
 * \brief Defines a command handler
 *
 * Defines a function named NAMEHandler where NAME if the given name.
 * The produced function signature is: void NAMEHandler(const char* command);
 * Example:
 *
 *  COMMAND_HANDLER(commands,
 *      COMMAND(...)
 *      COMMAND(...)
 *      COMMAND(...)
 *  )
 *
 *  Will create the function : void commandsHandler(const char* command)
 *
 *  The body of the function MUST be generated by COMMAND macros.
 *
 * \param NAME The prefix for the produced command handle
 * \param commands Successive calls to COMMAND macro
 */
#define COMMAND_HANDLER(NAME, commands) \
void NAME##Handler (const char* command) { \
    char* listOfCommands = malloc(16); \
    memcpy(listOfCommands, "Known commands:", 16); \
    listOfCommands[15] = '\0'; \
    commands; \
    ui_errorMessage(listOfCommands); \
    free(listOfCommands); \
}

/**
 * \def COMMAND
 * \brief Defines a command
 *
 * This macro must be called as a parameter of COMMAND_HANDLER macro (see COMMAND_HANDLER macro documentation).
 * Multiple COMMAND call can be nested and once a command is handled, a return call must be made to avoid
 * error message display.
 *
 * Example of COMMAND macro call :
 *
 *  COMMAND(users, "users <create | delete | list>",
 *      COMMAND(delete, "users delete <user>",
 *          if (strlen(command) > 0) {
 *              // Delete user
 *              return;
 *          }
 *      )
 *      COMMAND(create, "users create <user>",
 *          if (strlen(command) > 0) {
 *              // Create user
 *              return;
 *          }
 *      )
 *      COMMAND(list, "users list",
 *          // List users
 *          return;
 *      )
 *  )
 *
 *
 * \param NAME The command name (raw identifier)
 * \param usage The command usage (string)
 * \param next The code to execute on command match
 */
#define COMMAND(NAME, usage, next) \
{ \
    unsigned int listLength = strlen(listOfCommands); \
    unsigned int commandLength = strlen(usage); \
    char* listOfCommandsCopy = malloc(listLength + 1 + commandLength + 1); \
    memcpy(listOfCommandsCopy, listOfCommands, listLength); \
    listOfCommandsCopy[listLength] = '\n'; \
    memcpy(listOfCommandsCopy + listLength + 1, usage, commandLength); \
    listOfCommandsCopy[listLength + 1 + commandLength] = '\0'; \
    free(listOfCommands); \
    listOfCommands = listOfCommandsCopy; \
} \
if ( \
    strncmp(#NAME, command, strlen(#NAME)) == 0 && strlen(#NAME) == strlen(command) || \
    strncmp(#NAME, command, strlen(#NAME)) == 0 && strncmp(" ", command + strlen(#NAME), 1) == 0 \
) {\
    command = command + strlen(#NAME); \
    int commandLength##NAME = strlen(command); \
    while (commandLength##NAME > 0 && command[0] == ' ') { \
        command += 1; \
        commandLength##NAME = strlen(command); \
    } \
    next; \
    ui_errorMessage(usage); \
    return;\
};

#endif //C_CHAT_COMMANDS_H
